(self.webpackChunkblog=self.webpackChunkblog||[]).push([[515],{81515:n=>{n.exports="## [154. 寻找旋转排序数组中的最小值 II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/)\n\n假设按照升序排序的数组在预先未知的某个点上进行了旋转。\n\n( 例如，数组` [0,1,2,4,5,6,7] `可能变为` [4,5,6,7,0,1,2]` )。\n\n请找出其中最小的元素。\n\n注意数组中可能存在重复的元素。\n\n**示例 1：**\n\n```\n输入: [1,3,5]\n输出: 1\n```\n\n**示例 2：**\n\n```\n输入: [2,2,2,0,1]\n输出: 0\n```\n\n#### 解题思路\n\n类似题目81的解法，每次知道半边的有序，而这个半边有序就可以获取这半边的最小值，然后继续二分搜索另外半边\n\nC++实现：\n\n```c++\nclass Solution {\npublic:\n    int findMin(vector<int> &nums) {\n        int res = nums[0];\n        int left = 0, right = nums.size() - 1, mid;\n        while (left <= right) {\n            mid = (left + right) / 2;\n            if (nums[mid] == nums[left]){\n                res = min(res, nums[mid]);\n                ++left;\n            }\n            else if (nums[mid] > nums[left]) {\n                res = min(nums[left], res);\n                left = mid + 1;\n            } else {\n                res = min(res, nums[mid]);\n                right = mid - 1;\n            }\n        }\n        return res;\n    }\n};\n```\n\nPython实现：\n\n```python\nclass Solution:\n    def findMin(self, nums: List[int]) -> int:\n        left, right = 0, len(nums) - 1\n        res = nums[0]\n        while left <= right:\n            mid = (left + right) // 2\n            res = min(res, nums[mid])\n            if nums[mid] == nums[left]:\n                left += 1\n            elif nums[mid] > nums[left]:\n                # 左半边有序\n                res = min(res, nums[left])\n                left = mid + 1\n            else:\n                # 右半边有序\n                right = mid - 1\n        return res\n```\n\n"}}]);