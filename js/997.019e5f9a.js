(self.webpackChunkblog=self.webpackChunkblog||[]).push([[997],{94997:n=>{n.exports='## [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)\n\n给你一个字符串 `s` 、一个字符串` t` 。返回 `s `中涵盖` t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t `所有字符的子串，则返回空字符串 `"" `。\n\n注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。\n\n**示例 1：**\n\n```\n输入：s = "ADOBECODEBANC", t = "ABC"\n输出："BANC"\n```\n\n**示例 2：**\n\n```\n输入：s = "a", t = "a"\n输出："a"\n```\n\n#### 解题思路\n\n本题使用滑动窗口求解，即两个指针`l` 和 `r` 都是从最左端向最右端移动，且 `l` 的位置一定在`r` 的左边或重合。注意本题虽然在` for` 循环里出现了一个 `while` 循环，但是因为` while` 循环负责移动 `l` 指针，且 `l`只会从左到右移动一次，因此总时间复杂度仍然是 `O(n)`。本题使用了长度为 128的数组来映射字符，也可以用哈希表替代；其中 `chars` 表示目前每个字符缺少的数量，`flag` 表示每个字符是否在` T `中存在。\n\nC++实现：\n\n```cpp\nclass Solution {\npublic:\n    string minWindow(string s, string t) {\n        vector<int> chars(128, 0);\n        vector<bool> flag(128, false);\n        for (int i = 0; i < t.size(); ++i) {\n            flag[t[i]] = true;\n            ++chars[t[i]];\n        }\n        int cnt = 0, l = 0, min_l = 0, min_size = s.size() + 1;\n        for (int r = 0; r < s.size(); ++r) {\n            if (flag[s[r]]) {\n                if (--chars[s[r]] >= 0) {\n                    ++cnt;\n                }\n                while (cnt == t.size()) {\n                    if (r - l + 1 < min_size) {\n                        min_l = l;\n                        min_size = r - l + 1;\n                    }\n                    if (flag[s[l]] && ++chars[s[l]] > 0)\n                        --cnt;\n                    ++l;\n                }\n            }\n        }\n        return min_size > s.size() ? "" : s.substr(min_l, min_size);\n    }\n};\n```\n\nPython实现：\n\n```python\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        chartonum = Counter(t)\n        total_num, cur_num = len(t), 0\n        left = 0\n        res = [0, len(s) + 1]\n        for i, c in enumerate(s):\n            if c in chartonum:\n                if chartonum[c] > 0:\n                    cur_num += 1\n                chartonum[c] -= 1\n                # 移动左边\n                while cur_num == total_num:\n                    if res[1] - res[0] > i + 1 - left:\n                        res = [left, i + 1]\n                    if s[left] in chartonum:\n                        if chartonum[s[left]] >= 0:\n                            cur_num -= 1\n                        chartonum[s[left]] += 1\n                    left += 1\n        return \'\' if res[1] - res[0] == len(s) + 1 else s[res[0]: res[1]]\n```\n\n'}}]);