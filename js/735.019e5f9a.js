(self.webpackChunkblog=self.webpackChunkblog||[]).push([[735],{80735:n=>{n.exports='## [680. 验证回文字符串 Ⅱ](https://leetcode-cn.com/problems/valid-palindrome-ii/)\n\n给定一个非空字符串 `s`，**最多**删除一个字符。判断是否能成为回文字符串。\n\n**示例1 ：**\n\n```\n输入: "aba"\n输出: True\n```\n\n**示例2 ：**\n\n```\n输入: "abca"\n输出: True\n解释: 你可以删除c字符。\n```\n\n#### 解题思路\n\n采用双指针，从两头进行收缩，分为两种情况：\n\n1. 当`s[left]==s[right]`：则分别`left+1, right-1`\n2. 如果`s[left]!=s[right]`：则分别判断`[left+1, right]`和`[left, right+1]`是否是回文字符，如果是返回`true`，否则返回`false`\n\nC++实现：\n\n```cpp\nclass Solution {\npublic:\n    bool isPalindrome(string &s, int left, int right) {\n        while (left < right) {\n            if (s[left] == s[right]) {\n                ++left;\n                --right;\n            } else\n                return false;\n        }\n        return true;\n    }\n\n    bool validPalindrome(string s) {\n        int left = 0, right = s.size() - 1;\n        while (left < right) {\n            if (s[left] == s[right]) {\n                ++left;\n                --right;\n            } else {\n                return isPalindrome(s, left + 1, right) || isPalindrome(s, left, right - 1);\n            }\n        }\n        return true;\n    }\n};\n```\n\nPython实现：\n\n```python\nclass Solution:\n    def isPalindrome(self, s: str):\n        left, right = 0, len(s) - 1\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            else:\n                return False\n        return True\n\n    def validPalindrome(self, s: str) -> bool:\n        left, right = 0, len(s) - 1\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            else:\n                return self.isPalindrome(s[left + 1:right + 1]) or self.isPalindrome(s[left:right])\n        return True\n```\n\n'}}]);