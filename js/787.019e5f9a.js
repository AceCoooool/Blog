(self.webpackChunkblog=self.webpackChunkblog||[]).push([[787],{22787:n=>{n.exports='## 排序算法\n下述内容来自：[1.0 十大经典排序算法 | 菜鸟教程](https://www.runoob.com/w3cnote/ten-sorting-algorithm.html)\n\n### 冒泡排序\n\n冒泡排序（Bubble Sort）是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢"浮"到数列的顶端。\n\n核心步骤：\n\n- 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\n- 针对所有的元素重复以上的步骤，除了最后一个。\n- 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n\nC++实现：\n\n```cpp\nclass Solution {\npublic:\n    void bubble_sort(vector<int> &nums) {\n        int n = nums.size();\n        bool swapped;\n        for (int i = 1; i < n; ++i) {\n            swapped = false;\n            for (int j = 1; j < n - i + 1; ++j) {\n                if (nums[j] < nums[j - 1]) {\n                    swap(nums[j], nums[j - 1]);\n                    swapped = true;\n                }\n            }\n            if (!swapped)\n                break;\n        }\n    }\n};\n```\n\nPython实现：\n\n```python\nclass Solution:\n    def bubble_sort(self, nums: List[int]):\n        for i in range(1, len(nums)):\n            swapped = False\n            for j in range(1, len(nums) - i + 1):\n                if nums[j] < nums[j - 1]:\n                    nums[j], nums[j - 1] = nums[j - 1], nums[j]\n                    swapped = True\n            if not swapped:\n                break\n```\n\n### 选择排序\n\n选择排序是一种简单直观的排序算法，无论什么数据进去都是$O(n^2)$的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。\n\n核心步骤：\n\n- 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。\n\n- 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。\n\n- 重复第二步，直到所有元素均排序完毕。\n\nC++实现：\n\n```cpp\nclass Solution {\npublic:\n    void selection_sort(vector<int> &nums) {\n        int select, n = nums.size();\n        for (int i = 0; i < n - 1; ++i) {\n            select = i;\n            for (int j = i + 1; j < n; ++j) {\n                if (nums[j] < nums[select])\n                    select = j;\n            }\n            swap(nums[i], nums[select]);\n        }\n    }\n};\n```\n\nPython实现：\n\n```python\nclass Solution:\n    def selection_sort(self, nums: List[int]):\n        for i in range(0, len(nums) - 1):\n            pos = i\n            for j in range(i + 1, len(nums)):\n                if nums[j] < nums[pos]:\n                    pos = j\n            nums[i], nums[pos] = nums[pos], nums[i]\n```\n\n### 插入排序\n\n插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。\n\n核心步骤：\n\n- 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。\n- 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）\n\nC++实现：\n\n```cpp\nclass Solution {\npublic:\n    void insertion_sort(vector<int> &nums) {\n        for (int i = 0; i < nums.size(); ++i) {\n            for (int j = i; j > 0 && nums[j] < nums[j - 1]; --j)\n                swap(nums[j], nums[j - 1]);\n        }\n    }\n};\n```\n\nPython实现：\n\n```python\nclass Solution:\n    def insertion_sort(self, nums: List[int]):\n        for i in range(len(nums)):\n            for j in range(i, 0, -1):\n                if nums[j] < nums[j - 1]:\n                    nums[j], nums[j - 1] = nums[j - 1], nums[j]\n                else:\n                    break\n```\n\n'}}]);