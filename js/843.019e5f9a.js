(self.webpackChunkblog=self.webpackChunkblog||[]).push([[843],{70843:n=>{n.exports="## [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)\n\n给定一个按照升序排列的整数数组 `nums`，和一个目标值 `target`。找出给定目标值在数组中的开始位置和结束位置。\n\n如果数组中不存在目标值 `target`，返回 `[-1, -1]`。\n\n进阶：\n\n- 你可以设计并实现时间复杂度为 $O(log n)$ 的算法解决此问题吗？\n\n**示例 1：**\n\n```\n输入：nums = [5,7,7,8,8,10], target = 8\n输出：[3,4]\n```\n\n**示例 2：**\n\n```\n输入：nums = [5,7,7,8,8,10], target = 6\n输出：[-1,-1]\n```\n\n**示例 3：**\n\n```\n输入：nums = [], target = 0\n输出：[-1,-1]\n```\n\n#### 解题思路\n\n其实就是binary-search的lower_bound和upper_bound问题\n\nC++实现：\n\n```cpp\nclass Solution {\npublic:\n    int lower_bound(vector<int> &nums, int target) {\n        int left = 0, right = nums.size() - 1, mid;\n        while (left < right) {\n            mid = (left + right) / 2;\n            if (nums[mid] >= target)\n                right = mid;\n            else\n                left = mid + 1;\n        }\n        return nums[right] != target ? -1 : right;\n    }\n\n    int upper_bound(vector<int> &nums, int target) {\n        int left = 0, right = nums.size() - 1, mid;\n        while (left <= right) {\n            mid = (left + right) / 2;\n            if (nums[mid] <= target)\n                left = mid + 1;\n            else\n                right = mid - 1;\n        }\n        return (left > 0 && nums[left - 1] != target) ? -1 : left - 1;\n    }\n\n    vector<int> searchRange(vector<int> &nums, int target) {\n        if (nums.size() == 0) {\n            return {-1, -1};\n        }\n        int left = lower_bound(nums, target);\n        int right = upper_bound(nums, target);\n        return {left, right};\n    }\n};\n```\n\nPython实现：\n\n```python\nclass Solution:\n    def search_left(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] >= target:\n                right = mid\n            else:  # 保证了最后一次进入必然满足<target\n                left = mid + 1\n        return left if left < len(nums) and nums[left] == target else -1\n\n    def search_right(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > target:\n                right = mid\n            else:  # 保证最后一次进入必然满足<=target\n                left = mid + 1\n        return left - 1 if (left > 0 and nums[left - 1] == target) else -1\n\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        left = self.search_left(nums, target)\n        right = self.search_right(nums, target)\n        return [left, right]\n```"}}]);