(self.webpackChunkblog=self.webpackChunkblog||[]).push([[934],{29934:n=>{n.exports='## [524. 通过删除字母匹配到字典里最长单词](https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/)\n\n给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。\n\n**示例1 ：**\n\n```\n输入:\ns = "abpcplea", d = ["ale","apple","monkey","plea"]\n\n输出: \n"apple"\n```\n\n**示例2 ：**\n\n```\n输入:\ns = "abpcplea", d = ["a","b","c"]\n\n输出: \n"a"\n```\n\n#### 解题思路\n\n首先对`d`中的字符串进行排序：字符长度优先，如果字符串长度相同则比较两个字符串的大小，小的优先；\n\n然后将`s`和`d`中的字符串挨个匹配，如果匹配上则返回`d`：\n\n- 匹配按照`s`的遍历，如果和`d`当前位置字符匹配上，则将`d`的位置往后移一个；如果最终`d`到达末尾，则代表匹配\n\nC++实现：\n\n```cpp\nclass Solution {\npublic:\n    string findLongestWord(string s, vector<string> &d) {\n        sort(d.begin(), d.end(),\n             [](string &a, string &b) { return a.size() > b.size() ? true : (a.size() < b.size()) ? false : a < b; });\n        int idx_a;\n        for (string &a: d) {\n            if (a.size() > s.size()) {\n                continue;\n            }\n            idx_a = 0;\n            for (int i = 0; i < s.size(); ++i) {\n                if (s[i] == a[idx_a]) {\n                    ++idx_a;\n                    if (idx_a == a.size())\n                        return a;\n                }\n            }\n        }\n        return "";\n    }\n};\n```\n\nPython实现：\n\n```python\nclass Solution:\n    def is_sub_str(self, s: str, t: str) -> bool:\n        pointer, l = 0, len(s)\n        for c in t:\n            while pointer < l and s[pointer] != c:\n                pointer += 1\n            if pointer >= l:\n                return False\n            pointer += 1\n        return True\n\n    def findLongestWord(self, s: str, d: List[str]) -> str:\n        d.sort(key=lambda a: (-len(a), a))\n        for t in d:\n            if self.is_sub_str(s, t):\n                return t\n        return ""\n```\n\n'}}]);